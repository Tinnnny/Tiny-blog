(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{386:function(e,n,t){"use strict";t.r(n);var a=t(25),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"javabean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javabean"}},[e._v("#")]),e._v(" JavaBean")]),e._v(" "),t("p",[e._v("在Java中，有很多class的定义都符合这样的规范：")]),e._v(" "),t("p",[e._v("若干private实例字段；\n通过public方法来读写实例字段。\n例如：")]),e._v(" "),t("p",[e._v("public class Person {\nprivate String name;\nprivate int age;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public String getName() { return this.name; }\npublic void setName(String name) { this.name = name; }\n\npublic int getAge() { return this.age; }\npublic void setAge(int age) { this.age = age; }\n")])])]),t("p",[e._v("}\n如果读写方法符合以下这种命名规范：")]),e._v(" "),t("p",[e._v("// 读方法:\npublic Type getXyz()\n// 写方法:\npublic void setXyz(Type value)\n那么这种class被称为JavaBean：")]),e._v(" "),t("p",[e._v("java-bean")]),e._v(" "),t("p",[e._v("上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。")]),e._v(" "),t("p",[e._v("boolean字段比较特殊，它的读方法一般命名为isXyz()：")]),e._v(" "),t("p",[e._v("// 读方法:\npublic boolean isChild()\n// 写方法:\npublic void setChild(boolean value)\n我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性：")]),e._v(" "),t("p",[e._v("对应的读方法是String getName()\n对应的写方法是setName(String)\n只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性：")]),e._v(" "),t("p",[e._v("对应的读方法是int getAge()\n无对应的写方法setAge(int)\n类似的，只有setter的属性称为只写属性（write-only）。")]),e._v(" "),t("p",[e._v("很明显，只读属性很常见，只写属性不常见。")]),e._v(" "),t("p",[e._v("属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下：")]),e._v(" "),t("p",[e._v("public class Person {\nprivate String name;\nprivate int age;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public String getName() { return this.name; }\npublic void setName(String name) { this.name = name; }\n\npublic int getAge() { return this.age; }\npublic void setAge(int age) { this.age = age; }\n\npublic boolean isChild() {\n    return age <= 6;\n}\n")])])]),t("p",[e._v("}\n可以看出，getter和setter也是一种数据封装的方法。")]),e._v(" "),t("p",[e._v("JavaBean的作用\nJavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。")]),e._v(" "),t("p",[e._v("通过IDE，可以快速生成getter和setter。例如，在Eclipse中，先输入以下代码：")]),e._v(" "),t("p",[e._v("public class Person {\nprivate String name;\nprivate int age;\n}\n然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成getter和setter方法的字段，点击确定即可由IDE自动完成所有方法代码。")]),e._v(" "),t("p",[e._v("枚举JavaBean属性\n要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector：")]),e._v(" "),t("p",[e._v("import java.beans.*;")]),e._v(" "),t("p",[e._v('public class Main {\npublic static void main(String[] args) throws Exception {\nBeanInfo info = Introspector.getBeanInfo(Person.class);\nfor (PropertyDescriptor pd : info.getPropertyDescriptors()) {\nSystem.out.println(pd.getName());\nSystem.out.println("  " + pd.getReadMethod());\nSystem.out.println("  " + pd.getWriteMethod());\n}\n}\n}')]),e._v(" "),t("p",[e._v("class Person {\nprivate String name;\nprivate int age;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic int getAge() {\n    return age;\n}\n\npublic void setAge(int age) {\n    this.age = age;\n}\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("Run\n运行上述代码，可以列出所有的属性，以及对应的读写方法。注意class属性是从Object继承的getClass()方法带来的。")])])}),[],!1,null,null,null);n.default=i.exports}}]);