(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{387:function(n,t,i){"use strict";i.r(t);var o=i(25),r=Object(o.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"记录类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#记录类"}},[n._v("#")]),n._v(" 记录类")]),n._v(" "),i("p",[n._v("使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点：")]),n._v(" "),i("p",[n._v("定义class时使用final，无法派生子类；\n每个字段使用final，保证创建实例后无法修改任何字段。\n假设我们希望定义一个Point类，有x、y两个变量，同时它是一个不变类，可以这么写：")]),n._v(" "),i("p",[n._v("public final class Point {\nprivate final int x;\nprivate final int y;")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n}\n\npublic int x() {\n    return this.x;\n}\n\npublic int y() {\n    return this.y;\n}\n")])])]),i("p",[n._v("}\n为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写equals()和hashCode()，这里演示Point不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。")]),n._v(" "),i("p",[n._v("record\n从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record。把上述Point类改写为Record类，代码如下：")]),n._v(" "),i("p",[n._v("// Record")]),n._v(" "),i("p",[n._v("public class Main {\npublic static void main(String[] args) {\nPoint p = new Point(123, 456);\nSystem.out.println(p.x());\nSystem.out.println(p.y());\nSystem.out.println(p);\n}\n}")]),n._v(" "),i("p",[n._v("public record Point(int x, int y) {}")]),n._v(" "),i("p",[n._v("Run\n仔细观察Point的定义：")]),n._v(" "),i("p",[n._v("public record Point(int x, int y) {}\n把上述定义改写为class，相当于以下代码：")]),n._v(" "),i("p",[n._v("public final class Point extends Record {\nprivate final int x;\nprivate final int y;")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n}\n\npublic int x() {\n    return this.x;\n}\n\npublic int y() {\n    return this.y;\n}\n\npublic String toString() {\n    return String.format("Point[x=%s, y=%s]", x, y);\n}\n\npublic boolean equals(Object o) {\n    ...\n}\npublic int hashCode() {\n    ...\n}\n')])])]),i("p",[n._v("}\n除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。")]),n._v(" "),i("p",[n._v("换句话说，使用record关键字，可以一行写出一个不变类。")]),n._v(" "),i("p",[n._v("和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。")]),n._v(" "),i("p",[n._v("构造方法\n编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？")]),n._v(" "),i("p",[n._v("假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑：")]),n._v(" "),i("p",[n._v("public record Point(int x, int y) {\npublic Point {\nif (x < 0 || y < 0) {\nthrow new IllegalArgumentException();\n}\n}\n}\n注意到方法public Point {...}被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：")]),n._v(" "),i("p",[n._v("public final class Point extends Record {\npublic Point(int x, int y) {\n// 这是我们编写的Compact Constructor:\nif (x < 0 || y < 0) {\nthrow new IllegalArgumentException();\n}\n// 这是编译器继续生成的赋值代码:\nthis.x = x;\nthis.y = y;\n}\n...\n}\n作为record的Point仍然可以添加静态方法。一种常用的静态方法是of()方法，用来创建Point：")]),n._v(" "),i("p",[n._v("public record Point(int x, int y) {\npublic static Point of() {\nreturn new Point(0, 0);\n}\npublic static Point of(int x, int y) {\nreturn new Point(x, y);\n}\n}\n这样我们可以写出更简洁的代码：")]),n._v(" "),i("p",[n._v("var z = Point.of();\nvar p = Point.of(123, 456);")])])}),[],!1,null,null,null);t.default=r.exports}}]);