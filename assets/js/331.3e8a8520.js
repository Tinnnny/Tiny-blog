(window.webpackJsonp=window.webpackJsonp||[]).push([[331],{682:function(_,v,t){"use strict";t.r(v);var s=t(25),i=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"spring的事务管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务管理"}},[_._v("#")]),_._v(" Spring的事务管理")]),_._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),t("p",[_._v("事务原本是数据库中的概念，用于数据访问层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。Spring 事务的默认回滚方式是：发生运行时异常回滚。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("在 Spring 中通常可以通过以下三种方式来实现对事务的管理：")]),_._v(" "),t("ul",[t("li",[_._v("使用 Spring 的事务代理工厂管理事务（已过时）")]),_._v(" "),t("li",[_._v("使用 Spring 的事务注解管理事务")]),_._v(" "),t("li",[_._v("使用 AspectJ 的 AOP 配置管理事务")])])]),_._v(" "),t("h2",{attrs:{id:"事务定义接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务定义接口"}},[_._v("#")]),_._v(" 事务定义接口")]),_._v(" "),t("p",[_._v("事务定义接口 "),t("code",[_._v("TransactionDefinition")]),_._v(" 中定义了事务描述相关的三类常量："),t("code",[_._v("事务隔离级别")]),_._v("、"),t("code",[_._v("事务传播行为")]),_._v("、"),t("code",[_._v("事务默认超时时限")]),_._v("，及对它们的操作。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("事务的四种隔离级别:")]),_._v(" "),t("ul",[t("li",[_._v("DEFAULT：采用 DB 默认的事务隔离级别。MySql 默认为 REPEATABLE_READ；Oracle 默认为：READ_COMMITTED；")]),_._v(" "),t("li",[_._v("READ_UNCOMMITTED：读未提交。未解决任何并发问题。")]),_._v(" "),t("li",[_._v("READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。")]),_._v(" "),t("li",[_._v("REPEATABLE_READ：可重复读。解决脏读、不可重复读。存在幻读。")]),_._v(" "),t("li",[_._v("SERIALIZABLE：串行化。不存在并发问题。")])])]),_._v(" "),t("p",[t("span",{staticStyle:{"font-size":"25px","margin-right":"200px","margin-left":"100px"}},[_._v("脏读")]),t("span",{staticStyle:{"font-size":"25px","margin-right":"150px"}},[_._v("不可重复读")]),t("span",{staticStyle:{"font-size":"25px"}},[_._v("幻读")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("事务A")]),_._v(" "),t("th",[_._v("事务B")]),_._v(" "),t("th",[_._v("事务A")]),_._v(" "),t("th",[_._v("事务B")]),_._v(" "),t("th",[_._v("事务A")]),_._v(" "),t("th",[_._v("事务B")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("TbUser  A.a()")]),_._v(" "),t("td",[_._v("用TbUser B.b()操作TbContent")]),_._v(" "),t("td",[_._v("TbUser A.a()")]),_._v(" "),t("td",[_._v("A.a()")]),_._v(" "),t("td",[_._v("List(TbUser)")]),_._v(" "),t("td",[_._v("add tbUser")])]),_._v(" "),t("tr",[t("td",[_._v("读取TbUser id=1")]),_._v(" "),t("td",[_._v("修改了id=2")]),_._v(" "),t("td",[_._v("读取TbUser id=1")]),_._v(" "),t("td",[_._v("TbUser id=2")]),_._v(" "),t("td",[_._v("TbUser.size=10")]),_._v(" "),t("td",[_._v("add tbUser")])]),_._v(" "),t("tr",[t("td",[_._v("读取TbUser id=2")]),_._v(" "),t("td",[_._v("报错回滚")]),_._v(" "),t("td",[_._v(".")]),_._v(" "),t("td",[_._v("commit")]),_._v(" "),t("td",[_._v(".")]),_._v(" "),t("td",[_._v("11")])]),_._v(" "),t("tr",[t("td",[_._v("读取TbUser id=1")]),_._v(" "),t("td"),_._v(" "),t("td",[_._v("读取TbUser id=2")]),_._v(" "),t("td"),_._v(" "),t("td",[_._v("TbUser.size=11")]),_._v(" "),t("td",[_._v(".")])])])]),_._v(" "),t("p",[_._v("所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 a() 调用 B 事务中的方法 b()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("事务的七种传播行为:")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("REQUIRED")]),_._v("：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。")]),_._v(" "),t("li",[t("code",[_._v("SUPPORTS")]),_._v("：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。")]),_._v(" "),t("li",[t("code",[_._v("MANDATORY")]),_._v("：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。")]),_._v(" "),t("li",[t("code",[_._v("REQUIRES_NEW")]),_._v("：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。")]),_._v(" "),t("li",[t("code",[_._v("NOT_SUPPORTED")]),_._v("：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。")]),_._v(" "),t("li",[t("code",[_._v("NEVER")]),_._v("：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。")]),_._v(" "),t("li",[t("code",[_._v("NESTED")]),_._v("：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。")])])]),_._v(" "),t("p",[_._v("隔离级别需要记住，传播行为只要记住"),t("code",[_._v("required")]),_._v("就行。")])])}),[],!1,null,null,null);v.default=i.exports}}]);