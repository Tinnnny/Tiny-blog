(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{414:function(a,s,t){"use strict";t.r(s);var r=t(25),e=Object(r.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),t("p",[a._v("设计模式(Design Patterns)是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。")]),a._v(" "),t("p",[a._v("设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并写了一本Design Patterns的书。这四人也被称为四人帮（GoF）。")]),a._v(" "),t("p",[a._v("使用设计模式根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：")]),a._v(" "),t("h2",{attrs:{id:"开闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[a._v("#")]),a._v(" 开闭原则")]),a._v(" "),t("p",[a._v("由Bertrand Meyer提出的开闭原则(Open Closed Principle)是指，软件应该对扩展开放，对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能那是最好的。")]),a._v(" "),t("h2",{attrs:{id:"里氏替换原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[a._v("#")]),a._v(" 里氏替换原则")]),a._v(" "),t("p",[a._v("里氏替换原则是Barbara Liskov提出的，子类可以扩展父类的功能，但不能改变原有父类的功能。")]),a._v(" "),t("p",[a._v("设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为"),t("strong",[a._v("创建型模式")]),a._v("、"),t("strong",[a._v("结构型模式")]),a._v("和"),t("strong",[a._v("行为型模式")]),a._v("三类。")]),a._v(" "),t("h2",{attrs:{id:"单一职责原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[a._v("#")]),a._v(" 单一职责原则")]),a._v(" "),t("p",[a._v("一个类或者一个方法只负责一项职责。")]),a._v(" "),t("h2",{attrs:{id:"接口隔离原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[a._v("#")]),a._v(" 接口隔离原则")]),a._v(" "),t("p",[a._v("使用多个专门的接口，而不使用单一的总接口。即 客户端不应该依赖于那些它不需要的接口。")]),a._v(" "),t("h2",{attrs:{id:"依赖倒置原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[a._v("#")]),a._v(" 依赖倒置原则")]),a._v(" "),t("p",[a._v("面向抽象编程，抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而非针对实现编程。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),a._v(" xm "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("XiaoMing")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h2",{attrs:{id:"迪米特法则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[a._v("#")]),a._v(" 迪米特法则")]),a._v(" "),t("p",[a._v("也叫最少知识原则。如果两个类不彼此通信，那么这两个类就不应当直接地发生相互作用。如果其中一个类需要另一个类的某一个方法的话，可以通过第三者转发这个调用。")])])}),[],!1,null,null,null);s.default=e.exports}}]);