(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{493:function(t,v,s){"use strict";s.r(v);var _=s(25),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),s("p",[s("strong",[t._v("Java类只支持单继承")]),t._v("，不支持多继承但支持多层继承。顶层父类是Object类。所有的类默认继承Object，作为父类。")]),t._v(" "),s("h2",{attrs:{id:"object类方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object类方法"}},[t._v("#")]),t._v(" Object类方法")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("clone()")]),t._v(":实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出"),s("code",[t._v("CloneNotSupportedException")]),t._v("异常。")]),t._v(" "),s("li",[s("code",[t._v("getClass()")]),t._v(":final方法，获取类。")]),t._v(" "),s("li",[s("code",[t._v("toString()")]),t._v(":该方法用得比较多，一般子类都有覆盖。")]),t._v(" "),s("li",[s("code",[t._v("finalize()")]),t._v(":在对象在销毁之前执行"),s("code",[t._v("finalize()")]),t._v("修饰的代码。")]),t._v(" "),s("li",[s("code",[t._v("equals()")]),t._v(":一般equals和"),s("code",[t._v("==")]),t._v("是不一样的，但是在Object中两者是一样的。")]),t._v(" "),s("li",[s("code",[t._v("hashCode()")]),t._v(":用于哈希查找，重写了equals方法一般都要重写hashCode方法。")]),t._v(" "),s("li",[s("code",[t._v("wait()")]),t._v(":使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。")]),t._v(" "),s("li",[s("code",[t._v("notify()")]),t._v(":唤醒在该对象上等待的某个线程。")]),t._v(" "),s("li",[s("code",[t._v("notifyAll()")]),t._v(":唤醒在该对象上等待的所有线程")])]),t._v(" "),s("p",[t._v("一般equals可以推出hashCode相等，但hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("equals()和==的区别")]),t._v(" "),s("ol",[s("li",[t._v("对象类型不同")])]),t._v(" "),s("ul",[s("li",[t._v("equals()：是超类Object中的方法。")]),t._v(" "),s("li",[t._v("==：是操作符。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("比较的对象不同")])]),t._v(" "),s("ul",[s("li",[t._v("equals()：检测两个对象是否相等，即两个对象的内容是否相等。")]),t._v(" "),s("li",[t._v("==：比较引用数据类型时对内存地址进行比较，基本数据类型时比较值。")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("运行速度不同")])]),t._v(" "),s("ul",[s("li",[t._v("equals()：没有==运行速度快。")]),t._v(" "),s("li",[t._v("==：运行速度比equals()快，因为==只是比较引用。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("🔥:由equals的源码可以看出这里定义的equals与"),s("code",[t._v("==")]),t._v("是"),s("strong",[t._v("等效")]),t._v("的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）"),s("strong",[t._v("对equals进行了重写")]),t._v("。")]),t._v(" "),s("p",[t._v("但是没有对equals进行重写的类就只能从Object类中继承equals方法，其equals方法与"),s("code",[t._v("==")]),t._v("就也是等效的，除非在此类中重写equals。")])]),t._v(" "),s("h2",{attrs:{id:"成员变量重名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#成员变量重名"}},[t._v("#")]),t._v(" 成员变量重名")]),t._v(" "),s("p",[t._v("子父类中出现了同名的成员变量时，在子类中可以使用super关键字访问父类中非私有成员变量。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("当以下三者重名时")]),t._v(" "),s("ul",[s("li",[t._v("局部变量：直接写成员变量名。")]),t._v(" "),s("li",[t._v("本类的成员变量：this.成员变量名。")]),t._v(" "),s("li",[t._v("父类的成员变量：super.成员变量名。")])])]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"http://ww1.sinaimg.cn/large/007Rnr4nly1g8heictm7ej30ji08j0wi.jpg"}})]),t._v(" "),s("p",[t._v("直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找。")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"http://ww1.sinaimg.cn/large/007Rnr4nly1g8heect6nlj30pv0h9tit.jpg"}})]),t._v(" "),s("h2",{attrs:{id:"构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[t._v("#")]),t._v(" 构造方法")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("继承关系中,父子类构造方法的访问特点：")]),t._v(" "),s("ul",[s("li",[t._v("子类构造方法中有一个默认隐含的"),s("code",[t._v("super()")]),t._v("调用，所以一定是先调用父类构造，后执行子类构造。")]),t._v(" "),s("li",[t._v("子类构造可以通过super关键字来调用父类重载构造。")]),t._v(" "),s("li",[t._v("super的父类构造调用，必须是子类构造方法的第一个语句,不能一个子类构造调用多次super构造。")])]),t._v(" "),s("p",[t._v("总结：子类必须调用父类构造方法,不写则赠送super();写了则用写的指定的super调用，super只能有一个，还必须是第一个。")])]),t._v(" "),s("h2",{attrs:{id:"super关键字的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#super关键字的用法"}},[t._v("#")]),t._v(" super关键字的用法")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("三种用法：")]),t._v(" "),s("ul",[s("li",[t._v("在子类的成员方法中，访问父类的成员变量。")]),t._v(" "),s("li",[t._v("在子类的成员方法中，访问父类的成员方法。")]),t._v(" "),s("li",[t._v("在子类的构造方法中，访问父类的构造方法。")])])]),t._v(" "),s("h2",{attrs:{id:"this关键字的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this关键字的用法"}},[t._v("#")]),t._v(" this关键字的用法")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("三种用法：")]),t._v(" "),s("ul",[s("li",[t._v("在本类的成员方法中，访问本类的成员变量。")]),t._v(" "),s("li",[t._v("在本类的成员方法中，访问本类的另一个成员方法。")]),t._v(" "),s("li",[t._v("在本类的构造方法中，访问本类的另一个构造方法。")])]),t._v(" "),s("p",[t._v("总结：this()构造方法调用必须是构造方法的第一个语句，唯一一个。所以super和this两种构造调用，不能同时使用。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);