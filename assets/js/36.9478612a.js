(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{392:function(n,t,a){"use strict";a.r(t);var e=a(25),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"常用工具类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用工具类"}},[n._v("#")]),n._v(" 常用工具类")]),n._v(" "),a("p",[n._v("Java的核心库提供了大量的现成的类供我们使用。本节我们介绍几个常用的工具类。")]),n._v(" "),a("p",[n._v("Math\n顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：")]),n._v(" "),a("p",[n._v("求绝对值：")]),n._v(" "),a("p",[n._v("Math.abs(-100); // 100\nMath.abs(-7.8); // 7.8\n取最大或最小值：")]),n._v(" "),a("p",[n._v("Math.max(100, 99); // 100\nMath.min(1.2, 2.3); // 1.2\n计算xy次方：")]),n._v(" "),a("p",[n._v("Math.pow(2, 10); // 2的10次方=1024\n计算√x：")]),n._v(" "),a("p",[n._v("Math.sqrt(2); // 1.414...\n计算ex次方：")]),n._v(" "),a("p",[n._v("Math.exp(2); // 7.389...\n计算以e为底的对数：")]),n._v(" "),a("p",[n._v("Math.log(4); // 1.386...\n计算以10为底的对数：")]),n._v(" "),a("p",[n._v("Math.log10(100); // 2\n三角函数：")]),n._v(" "),a("p",[n._v("Math.sin(3.14); // 0.00159...\nMath.cos(3.14); // -0.9999...\nMath.tan(3.14); // -0.0015...\nMath.asin(1.0); // 1.57079...\nMath.acos(1.0); // 0.0\nMath还提供了几个数学常量：")]),n._v(" "),a("p",[n._v("double pi = Math.PI; // 3.14159...\ndouble e = Math.E; // 2.7182818...\nMath.sin(Math.PI / 6); // sin(π/6) = 0.5\n生成一个随机数x，x的范围是0 <= x < 1：")]),n._v(" "),a("p",[n._v("Math.random(); // 0.53907... 每次都不一样\n如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下：")]),n._v(" "),a("p",[n._v("// 区间在[MIN, MAX)的随机数\npublic class Main {\npublic static void main(String[] args) {\ndouble x = Math.random(); // x的范围是[0,1)\ndouble min = 10;\ndouble max = 50;\ndouble y = x * (max - min) + min; // y的范围是[10,50)\nlong n = (long) y; // n的范围是[10,50)的整数\nSystem.out.println(y);\nSystem.out.println(n);\n}\n}")]),n._v(" "),a("p",[n._v("Run\n有些童鞋可能注意到Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。")]),n._v(" "),a("p",[n._v("Random\nRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。")]),n._v(" "),a("p",[n._v("要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：")]),n._v(" "),a("p",[n._v("Random r = new Random();\nr.nextInt(); // 2071575453,每次都不一样\nr.nextInt(10); // 5,生成一个[0,10)之间的int\nr.nextLong(); // 8811649292570369305,每次都不一样\nr.nextFloat(); // 0.54335...生成一个[0,1)之间的float\nr.nextDouble(); // 0.3716...生成一个[0,1)之间的double\n有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。")]),n._v(" "),a("p",[n._v("这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。")]),n._v(" "),a("p",[n._v("如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列：")]),n._v(" "),a("p",[n._v("import java.util.Random;")]),n._v(" "),a("p",[n._v("public class Main {\npublic static void main(String[] args) {\nRandom r = new Random(12345);\nfor (int i = 0; i < 10; i++) {\nSystem.out.println(r.nextInt(100));\n}\n// 51, 80, 41, 28, 55...\n}\n}")]),n._v(" "),a("p",[n._v("Run\n前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。")]),n._v(" "),a("p",[n._v("SecureRandom\n有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：")]),n._v(" "),a("p",[n._v("SecureRandom sr = new SecureRandom();\nSystem.out.println(sr.nextInt(100));\nSecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：")]),n._v(" "),a("p",[n._v("import java.util.Arrays;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;")]),n._v(" "),a("p",[n._v("public class Main {\npublic static void main(String[] args) {\nSecureRandom sr = null;\ntry {\nsr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器\n} catch (NoSuchAlgorithmException e) {\nsr = new SecureRandom(); // 获取普通的安全随机数生成器\n}\nbyte[] buffer = new byte[16];\nsr.nextBytes(buffer); // 用安全随机数填充buffer\nSystem.out.println(Arrays.toString(buffer));\n}\n}")]),n._v(" "),a("p",[n._v("Run\nSecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。")]),n._v(" "),a("p",[n._v("在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。")]),n._v(" "),a("p",[n._v("需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！")])])}),[],!1,null,null,null);t.default=r.exports}}]);